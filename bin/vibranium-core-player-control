#!/usr/bin/env bash

source "$VIBRANIUM_PATH/vibranium-core-lib"

check_enum VIBRANIUM_PLAYER_FADE_DURATION "normal" very_slow slow normal fast very_fast off
check_enum VIBRANIUM_PLAYER_FADE_DURATION_ON_SWITCH "slow" very_slow slow normal fast very_fast off

VOLUME_FILE="$XDG_RUNTIME_DIR/$(basename "$0")"
PLAYER_CACHE_FILE="$XDG_RUNTIME_DIR/$(basename "$0").player"
SLEEP_TIME=0.005  # Adjust this for overall speed; smaller = faster loops, but may strain CPU

# Map fade durations to number of steps (higher steps = slower fade, longer duration)
case "$VIBRANIUM_PLAYER_FADE_DURATION" in
    "very_slow") NUM_STEPS=200 ;;
    "slow")    NUM_STEPS=100 ;;
    "normal")  NUM_STEPS=50  ;;
    "fast")    NUM_STEPS=30  ;;
    "very_fast") NUM_STEPS=10 ;;
    "off")     NUM_STEPS="off" ;;
esac

case "$VIBRANIUM_PLAYER_FADE_DURATION_ON_SWITCH" in
    "very_slow") NUM_STEPS_SWITCH=200 ;;
    "slow")    NUM_STEPS_SWITCH=100 ;;
    "normal")  NUM_STEPS_SWITCH=50  ;;
    "fast")    NUM_STEPS_SWITCH=30  ;;
    "very_fast") NUM_STEPS_SWITCH=10 ;;
    "off")     NUM_STEPS_SWITCH="off" ;;
esac

# Function to check if a player is active and get its status
get_player_status() {
    local player="$1"
    if [ "$player" = "playerctl" ]; then
        local stat
        stat=$(playerctl status 2> /dev/null)
        if [ "$stat" = "Playing" ] || [ "$stat" = "Paused" ]; then
            echo "$stat"
            return 0
        fi
    elif [ "$player" = "mpd" ]; then
        local stat
        stat=$(mpc status 2> /dev/null | grep -oP '\[\K(playing|paused)')
        if [ -n "$stat" ]; then
            echo "${stat^}"  # Capitalize first letter
            return 0
        fi
    fi
    return 1
}

# Detect active player with priority to Playing
PLAYER=""
STATUS=""

# First, check for Playing players
if ! command -v mpc > /dev/null; then
    PLAYER="playerctl"
else
    for p in playerctl mpd; do
        stat=$(get_player_status "$p")
        if [ $? -eq 0 ] && [ "$stat" = "Playing" ]; then
            PLAYER="$p"
            STATUS="$stat"
            echo "$PLAYER" > "$PLAYER_CACHE_FILE"  # Update cache since it's Playing
            break
        fi
    done
fi


# If no Playing, check cache for Paused
if [ -z "$PLAYER" ] && [ -f "$PLAYER_CACHE_FILE" ]; then
    CACHED_PLAYER=$(< "$PLAYER_CACHE_FILE")
    stat=$(get_player_status "$CACHED_PLAYER")
    if [ $? -eq 0 ] && [ "$stat" = "Paused" ]; then
        PLAYER="$CACHED_PLAYER"
        STATUS="$stat"
    fi
fi

# If still no player, check for Paused players
if [ -z "$PLAYER" ]; then
    for p in playerctl mpd; do
        stat=$(get_player_status "$p")
        if [ $? -eq 0 ] && [ "$stat" = "Paused" ]; then
            PLAYER="$p"
            STATUS="$stat"
            break
        fi
    done
fi

# Fallback
if [ -z "$PLAYER" ]; then
    PLAYER="playerctl"
    STATUS=$(get_player_status "playerctl") || STATUS="Stopped"
fi

# Player abstraction functions
# Volumes are handled as floats 0-1 for consistency

get_volume() {
    if [ "$PLAYER" = "playerctl" ]; then
        playerctl volume 2> /dev/null
    elif [ "$PLAYER" = "mpd" ]; then
        mpc volume 2> /dev/null | sed 's/[^0-9]//g' | awk '{print $1 / 100}'
    fi
}

set_volume() {
    local vol="$1"
    if [ "$PLAYER" = "playerctl" ]; then
        playerctl volume "$vol" 2> /dev/null
    elif [ "$PLAYER" = "mpd" ]; then
        local int_vol
        int_vol=$(awk "BEGIN {printf \"%.0f\", $vol * 100}")
        mpc -q volume "$int_vol"
    fi
}

play() {
    if [ "$PLAYER" = "playerctl" ]; then
        playerctl play 2> /dev/null
    elif [ "$PLAYER" = "mpd" ]; then
        mpc -q play
    fi
    # Update cache
    echo "$PLAYER" > "$PLAYER_CACHE_FILE"
}

pause() {
    if [ "$PLAYER" = "playerctl" ]; then
        playerctl pause 2> /dev/null
    elif [ "$PLAYER" = "mpd" ]; then
        mpc -q pause
    fi
    # Update cache
    echo "$PLAYER" > "$PLAYER_CACHE_FILE"
}

next_track() {
    if [ "$PLAYER" = "playerctl" ]; then
        playerctl next 2> /dev/null
    elif [ "$PLAYER" = "mpd" ]; then
        mpc -q next
    fi
}

previous_track() {
    if [ "$PLAYER" = "playerctl" ]; then
        playerctl previous 2> /dev/null
    elif [ "$PLAYER" = "mpd" ]; then
        mpc -q prev
    fi
}

# Fade out to 0
fade_out() {
    local num_steps="$1"
    if [ "$num_steps" = "off" ]; then
        return 0
    fi

    local current
    current=$(get_volume)
    if awk "BEGIN {exit !($current <= 0)}"; then
        return  # Already at 0
    fi

    local step
    step=$(awk "BEGIN {print $current / $num_steps}")

    for ((i = 1; i <= num_steps; i++)); do
        local new_vol
        new_vol=$(awk "BEGIN {print $current - $i * $step}")
        set_volume "$new_vol"
        sleep "$SLEEP_TIME"
    done
    set_volume 0
}

# Fade in to target
fade_in() {
    local num_steps="$1"
    local target="$2"
    if [ "$num_steps" = "off" ]; then
        set_volume "$target"
        return
    fi
    if awk "BEGIN {exit !($target <= 0)}"; then
        return  # Target is 0
    fi
    local step
    step=$(awk "BEGIN {print $target / $num_steps}")
    for ((i = 1; i <= num_steps; i++)); do
        local new_vol
        new_vol=$(awk "BEGIN {print $i * $step}")
        set_volume "$new_vol"
        sleep "$SLEEP_TIME"
    done
    set_volume "$target"
}

CURRENT_VOLUME=$(get_volume)

case "$1" in
    "toggle")
        if [ "$STATUS" = "Playing" ]; then
            if [ "$NUM_STEPS" != "off" ]; then
                echo "$CURRENT_VOLUME" > "$VOLUME_FILE"
                fade_out "$NUM_STEPS"
            fi
            pause
            if [ "$NUM_STEPS" != "off" ]; then
                set_volume "$CURRENT_VOLUME"
            fi
        else
            if [ -f "$VOLUME_FILE" ]; then
                TARGET_VOLUME=$(< "$VOLUME_FILE")
                if [ "$NUM_STEPS" = "off" ]; then
                    play
                    rm "$VOLUME_FILE"
                    exit 0
                fi
                set_volume 0
                play
                fade_in "$NUM_STEPS" "$TARGET_VOLUME"
                rm "$VOLUME_FILE"
            else
                play
            fi
        fi
        ;;
    "play")
        if [ "$STATUS" != "Playing" ]; then
            if [ -f "$VOLUME_FILE" ]; then
                TARGET_VOLUME=$(< "$VOLUME_FILE")
                if [ "$NUM_STEPS" = "off" ]; then
                    play
                    rm "$VOLUME_FILE"
                else
                    set_volume 0
                    play
                    fade_in "$NUM_STEPS" "$TARGET_VOLUME"
                    rm "$VOLUME_FILE"
                fi
            else
                play
            fi
        fi
        ;;
    "pause")
        if [ "$STATUS" = "Playing" ]; then
            if [ "$NUM_STEPS" != "off" ]; then
                echo "$CURRENT_VOLUME" > "$VOLUME_FILE"
                fade_out "$NUM_STEPS"
            fi
            pause
            if [ "$NUM_STEPS" != "off" ]; then
                set_volume "$CURRENT_VOLUME"
            fi
        fi
        ;;
    "next" | "previous")
        if [ "$NUM_STEPS_SWITCH" = "off" ]; then
            if [ "$1" = "next" ]; then
                next_track
            else
                previous_track
            fi
            exit 0
        fi

        if [ "$STATUS" = "Paused" ]; then
            fade_out "$NUM_STEPS"
            play
            fade_out "$NUM_STEPS"
        fi

        original_volume="$CURRENT_VOLUME"
        fade_out "$NUM_STEPS_SWITCH"
        if [ "$1" = "next" ]; then
            next_track
        else
            previous_track
        fi
        fade_in "$NUM_STEPS_SWITCH" "$original_volume"
        ;;
    *)
        echo "Usage: $(basename "$0") <toggle|play|pause|next|previous>"
        exit 1
        ;;
esac
