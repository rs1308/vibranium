#!/usr/bin/env bash

# Overcomplicated script that manages brightness control using raw sysfs values
# as well as the DDC protocol for external monitors. The script uses state files to cache
# active values for both methods to speed up subsequent script executions.
# This is ESPECIALLY useful for the DDC method, because ddcutil is known to be quite slow.
# Thanks to the state file, changing brightness with DDC takes milliseconds instead of 500-700-1000ms.
# This script has not been tested with a dual (or triple) monitor setup (or hybrid), so I have no idea how it will work.
#
# The script can accept parameters such as up | down for relative brightness adjustment with dynamic steps using Vibranium settings,
# as well as absolute values such as 20, 50, 100, etc.

source "$VIBRANIUM_PATH/vibranium-core-lib"

usage() {
    cat << EOF
Usage:
	$(basename "$0") up|down|value
EOF
}

if pidof ddcutil > /dev/null; then
    exit 0
fi

if [[ -z "$1" || ! $1 =~ ^(up|down|[0-9]+)$ ]]; then
    usage
    exit 1
fi

ACTIVE_MONITOR="$(hyprctl -j monitors | jq -r '.[] | select(.focused == true) | .name')"

get_i2c_bus() {
    STATE_FILE="$VIBRANIUM_STATE/i2c-bus"

    NEW_INFO="$(ddcutil detect 2>/dev/null | awk '
        /I2C bus:/          { bus=$NF; sub("/dev/i2c-", "", bus); skip=0 }
        /DRM_connector:/    {
            name=$2
            if (name ~ /^card[0-9]+-eDP/) skip=1
            sub(/^card[0-9]+-/, "", name)
        }
        /This is a laptop/  { skip=1 }
        /VCP version/ && !skip { print name ":" bus }
    ')"

    declare -A OLD_INFO
    if [[ -f "$STATE_FILE" ]]; then
        while IFS=: read -r name bus; do
            [[ -n "$name" && -n "$bus" ]] && OLD_INFO["$name"]="$bus"
        done < "$STATE_FILE"
    fi

    while IFS=: read -r name bus; do
        [[ -n "$name" && -n "$bus" ]] && OLD_INFO["$name"]="$bus"
    done <<< "$NEW_INFO"

    {
        for name in "${!OLD_INFO[@]}"; do
            printf '%s:%s\n' "$name" "${OLD_INFO[$name]}"
        done
    } > "$STATE_FILE"
}

set_i2c_bus() {
    local i2c_info
    local final_bus

    if [[ ! -f "$VIBRANIUM_STATE/i2c-bus" ]]; then
        get_i2c_bus
    fi

    i2c_info="$(< "$VIBRANIUM_STATE/i2c-bus")"
    if [[ ! "$i2c_info" =~ $ACTIVE_MONITOR ]]; then
        get_i2c_bus
        unset i2c_info; i2c_info="$(< "$VIBRANIUM_STATE/i2c-bus")"
    fi

    while IFS= read -r line; do
        case "$line" in
            "$ACTIVE_MONITOR"*:*)
                final_bus="${line#*:}"
                break
                ;;
        esac
    done <<< "$i2c_info"

    echo "$final_bus"
}

get_brightness_cache() {
    STATE_FILE="$VIBRANIUM_STATE/brightness"

    declare -A OLD_INFO
    if [[ -f "$STATE_FILE" ]]; then
        while IFS=: read -r name value; do
            [[ -n "$name" && -n "$value" ]] && OLD_INFO["$name"]="$value"
        done < "$STATE_FILE"
    fi

    # If no entry for the active monitor, return empty to trigger a fresh fetch
    echo "${OLD_INFO["$ACTIVE_MONITOR"]}"
}

update_brightness_cache() {
    local new_value="$1"
    STATE_FILE="$VIBRANIUM_STATE/brightness"

    declare -A INFO
    if [[ -f "$STATE_FILE" ]]; then
        while IFS=: read -r name value; do
            [[ -n "$name" && -n "$value" ]] && INFO["$name"]="$value"
        done < "$STATE_FILE"
    fi

    INFO["$ACTIVE_MONITOR"]="$new_value"

    {
        for name in "${!INFO[@]}"; do
            printf '%s:%s\n' "$name" "${INFO[$name]}"
        done
    } > "$STATE_FILE"
}

if ! compgen -G "/sys/class/backlight/*" > /dev/null; then
    check_bool VIBRANIUM_BRIGHTNESS_USE_DDC_CONTROL false

    # If the driver for adjusting the brightness of the built-in screen is not found and DDC control is disabled globally
    if [[ $VIBRANIUM_BRIGHTNESS_USE_DDC_CONTROL == false ]]; then
        error "This feature is disabled in Vibranium settings"
        exit 1
    else
        if ! missing_str="$(vibranium-utils-is-installed ddcutil)"; then
            read -r -a missing <<< "$missing_str"
            notify-send -r 4 -t 5000 -u critical "Vibranium - Brightness Control" "Missing dependencies: ${missing[*]}"
            exit 1
        fi

        method="DDC"
        I2C_BUS="$(set_i2c_bus)"

        # TODO: As far as I know, optimal values for --sleep-multiplier can vary from monitor to monitor,
        # and while it works well on one monitor, it may not work at all on another.
        # In this case, we need to create a mini-algorithm that will calculate and record valid values for the monitor and use them.
        ddcutil_flags=(--sleep-multiplier 0.13 --noverify --skip-ddc-checks --maxtries 1,1,1)
    fi
else
    if [[ ! -z "$ACTIVE_MONITOR" ]] && [[ ! "$ACTIVE_MONITOR" =~ eDP* ]]; then
        method="DDC"
        I2C_BUS="$(set_i2c_bus)"
    else
        method="raw"
    fi
fi

[[ $VIBRANIUM_GLOBAL_USE_OSD == true ]] && [[ $VIBRANIUM_BRIGHTNESS_USE_OSD == true ]] && {
    if ! missing_str="$(vibranium-utils-is-installed swayosd:swayosd-client)"; then
        read -r -a missing <<< "$missing_str"
        notify-send -r 4 -t 5000 -u critical "Vibranium - Brightness Control" "Missing dependencies: ${missing[*]}"
    fi
}

osd() {
    local value="$1"
    local icon progress

    # Set specific icons depending on the current brightness level (icons are taken from the active icon pack)
    if ((value <= 30)); then
        icon="brightness-low-symbolic"
    elif ((value <= 70)); then
        icon="brightness-symbolic"
    else
        icon="brightness-high-symbolic"
    fi

    # Build a brightness value for SwayOSD
    progress=$(awk -v v="$value" 'BEGIN {p = 0.02 + v * (0.98/100); printf "%.2f", p}')

    # I can't imagine a situation where this service would be turned off, but let it be there just in case
    [[ ! $(pidof swayosd-server) ]] && systemctl --user enable --now swayosd
    swayosd-client --custom-icon="$icon" --custom-progress="$progress" || true
}

check_int VIBRANIUM_BRIGHTNESS_STEP 5 int
step=$VIBRANIUM_BRIGHTNESS_STEP

case "$method" in
    "DDC")
        current="$(get_brightness_cache)"
        if [[ ! $current =~ ^[0-9]+$ ]]; then
            retries=3
            for ((i = 0; i < retries; i++)); do
                # Same as above.
                # -----------------
                # As I mentioned above, --sleep-multiplier can sometimes fail at very low values,
                # so we give the command three attempts to get the date from the monitor using the DDC protocol.
                current=$(ddcutil --bus "$I2C_BUS" "${ddcutil_flags[@]}" getvcp 10 2> /dev/null | awk '/current/ {print int($9)}')
                if [[ $current =~ ^[0-9]+$ ]] && ((current >= 0 && current <= 100)); then
                    break
                fi
            done
            update_brightness_cache "$current"
        fi

        # The remaining code at the bottom is generally self-explanatory
        case "$1" in
            "up")
                ((current == 100)) && exit 0
                new=$((current + step))
                ((new > 100)) && new=100
                ;;
            "down")
                ((current == 0)) && exit 0
                new=$((current - step))
                ((new < 0)) && new=0
                ;;
            *)
                if [[ $1 =~ ^[0-9]+$ ]]; then
                    if ((current == 0 && $1 == 0)); then
                        exit 0
                    elif ((current == 100 && $1 == 100)); then
                        exit 0
                    fi

                    if (($1 >= 0 && $1 <= 100)); then
                        new=$1
                    else
                        error "Out of boundary"
                        exit 1
                    fi
                else
                    error "Invalid input!"
                    exit 1
                fi
                ;;
        esac

        log "Method: ${YELLOW}'""$method""'${RESET}"
        log "DDC flags: ${YELLOW}'""${ddcutil_flags[*]}""'${RESET}"
        log "Current brightness: ${YELLOW}'""${current}""'${RESET}"
        log "New brightness: ${YELLOW}'""$new""'${RESET}"

        ddcutil --bus "$I2C_BUS" "${ddcutil_flags[@]}" setvcp 10 "$new" &

        update_brightness_cache "$new"

        check_bool VIBRANIUM_BRIGHTNESS_USE_OSD true
        check_bool VIBRANIUM_GLOBAL_USE_OSD true

        if [[ $VIBRANIUM_GLOBAL_USE_OSD == true ]] && [[ $VIBRANIUM_BRIGHTNESS_USE_OSD == true ]]; then
            osd "$new" &
        else
            if [[ ! "$ACTIVE_MONITOR" =~ eDP* ]]; then
                source="($ACTIVE_MONITOR) "
            else
                source=""
            fi
            notify-send -r 2 -t 1000 "Brightness $source${new}%" -h int:value:"$new"
        fi
        ;;
    "raw")
        # Read current and max brightness from kernel
        current_raw=$(< /sys/class/backlight/*/brightness)
        max_raw=$(< /sys/class/backlight/*/max_brightness)
        current=$((current_raw * 100 / max_raw))

        case "$1" in
            up)
                # Step is in percent, convert to raw delta
                delta=$((step * max_raw / 100))
                new_raw=$((current_raw + delta))
                ;;
            down)
                delta=$((step * max_raw / 100))
                new_raw=$((current_raw - delta))
                ;;
            *)
                if [[ "$1" =~ ^[0-9]+$ && $1 -ge 0 && $1 -le 100 ]]; then
                    new_raw=$(( $1 * max_raw / 100 ))
                else
                    error "Invalid input!"
                    exit 1
                fi
                ;;
        esac

        # Clamp raw value
        ((new_raw > max_raw)) && new_raw=$max_raw
        ((new_raw < 0)) && new_raw=0

        # Convert back to percent for logs/OSD
        new=$((new_raw * 100 / max_raw))

        log "Method: ${YELLOW}'$method'${RESET}"
        log "Current brightness: ${YELLOW}'$current'${RESET}"
        log "New brightness: ${YELLOW}'$new'${RESET}"

        # Apply new brightness
        echo "$new_raw" > /sys/class/backlight/*/brightness

        if [[ $VIBRANIUM_GLOBAL_USE_OSD == true && $VIBRANIUM_BRIGHTNESS_USE_OSD == true ]]; then
            swayosd-client --brightness="$new"
        else
            notify-send -r 1 -t 1000 "Brightness ${new}%" -h int:value:"$new"
        fi
        ;;
esac
